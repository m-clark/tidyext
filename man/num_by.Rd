% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/num_by.R
\name{num_by}
\alias{num_by}
\alias{cat_by}
\title{Summarize data by groups}
\usage{
num_by(data, main_var, group_var, digits = 1, extra = FALSE)

cat_by(data, main_var, group_var, digits = FALSE, perc_by_group = TRUE,
  sort_by_group = TRUE)
}
\arguments{
\item{data}{data frame}

\item{main_var}{the variable to be summarized. Multiple variables are
supplied using the vars() function.}

\item{group_var}{the (optional) grouping variable.}

\item{digits}{Optional rounding. Default is 1.}

\item{extra}{See \link[tidyext]{num_summary}.}

\item{perc_by_group}{when supplied a grouping variable for cat_by, do you
want within group percentages also (default is TRUE)}

\item{sort_by_group}{when supplied a grouping variable for cat_by, do you
want result sorted on the grouping variable? Default is TRUE.}
}
\value{
data.frame/tibble with the corresponding summary statistics
}
\description{
Provide common numeric summary information.
}
\details{
The \code{num_by} function takes a numeric variable from a dataframe
  and provides sample size, mean, standard deviation, min, first quartile,
  median, third quartile, max, and number of missing values, possibly over a
  grouping variable.

  It works in the dplyr style using unquoted (bare) variable names, using the
  \code{vars()} function if there is more than one variable.  If using a
  grouping variable, it will treat missing values as a separate group.

  For \code{cat_by}, frequencies and percentage (out of total or group_var)
  are returned. Warnings are given if any of the main
  variables are more than 10 levels, or the data appears to be
  non-categorical. The group_var argument is essentially just to provide
  percentages based on a focal grouping variable out of all those supplied.
  Missing values are treated as an additional unique value.

  Missing values are treated as separate groups, as it's often useful to
  explore the nature of the missingness. To avoid this, just use
  \code{na.omit} or \code{dplyr::drop_na} on the data frame first.
}
\examples{
library(tidyext)
df1 <- data.frame(g1 = factor(sample(1:2, 50, replace = TRUE), labels=c('a','b')),
                  g2 = sample(1:4, 50, replace = TRUE),
                  a = rnorm(50),
                  b = rpois(50, 10),
                  c = sample(letters, 50, replace=TRUE),
                  d = sample(c(TRUE, FALSE), 50, replace=TRUE)
                 )


num_by(df1, main_var = a)
num_by(df1, main_var = a, group_var = g2, digits=2)

num_by(df1, main_var = dplyr::vars(a,b), group_var = g1, digits=1)

cat_by(df1, main_var = g1, group_var = g2, digits=1)
cat_by(df1, main_var = dplyr::vars(g1,d), group_var = g2, perc_by_group=FALSE)

}
\seealso{
describe_all
}
